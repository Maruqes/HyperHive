package npm

import (
	"bufio"
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/mail"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/Maruqes/512SvMan/logger"
)

const (
	image      = "jc21/nginx-proxy-manager:2.13.5"
	adminEmail = "admin@example.com" // change if you set INITIAL_ADMIN_EMAIL
	adminPass  = "changeme"          // change if you set INITIAL_ADMIN_PASSWORD

)

func waitForNPM(baseURL string, timeout time.Duration) error {
	deadline := time.Now().Add(timeout)
	client := &http.Client{Timeout: 3 * time.Second}

	// try a few endpoints that come up at slightly different times
	endpoints := []string{
		"/api/schema", // shows up a bit later on some versions
		"/api",        // generic
		"/",           // UI root (often 200/302 before /api)
	}

	for time.Now().Before(deadline) {
		for _, ep := range endpoints {
			resp, err := client.Get(baseURL + ep)
			if err == nil {
				io.Copy(io.Discard, resp.Body)
				resp.Body.Close()
				// 200–499 is “server up enough to answer”; 5xx means still starting
				if resp.StatusCode < 500 {
					return nil
				}
			}
		}
		time.Sleep(2 * time.Second)
	}
	return fmt.Errorf("npm not ready at %s within %s", baseURL, timeout)
}

func waitForAPI(baseURL string, timeout time.Duration) error {
	deadline := time.Now().Add(timeout)
	client := &http.Client{Timeout: 3 * time.Second}
	// endpoints that prove the backend (Node) is answering (401/404 is OK)
	checks := []string{"/api", "/api/schema"}

	for time.Now().Before(deadline) {
		for _, ep := range checks {
			resp, err := client.Get(baseURL + ep)
			if err == nil {
				io.Copy(io.Discard, resp.Body)
				resp.Body.Close()
				// treat any non-5xx as "backend is reachable"
				if resp.StatusCode < 500 {
					return nil
				}
			}
		}
		time.Sleep(2 * time.Second)
	}
	return fmt.Errorf("API not ready at %s within %s", baseURL, timeout)
}

func retry[T any](timeout, step time.Duration, fn func() (T, error)) (T, error) {
	var zero T
	deadline := time.Now().Add(timeout)
	for {
		val, err := fn()
		if err == nil {
			return val, nil
		}
		// retry on transient/5xx/connect errors
		if time.Now().After(deadline) {
			return zero, err
		}
		time.Sleep(step)
		logger.Warn("Retrying after error:", err)
	}
}

func PullImage() error {
	// 1) Ensure data dirs
	work, err := os.Getwd()
	if err != nil {
		return err
	}

	data := filepath.Join(work, "npm-data")
	ssl := filepath.Join(work, "npm-ssl")
	if err := os.MkdirAll(data, 0o755); err != nil {
		return err
	}
	logDir := filepath.Join(data, "logs")
	if err := os.MkdirAll(logDir, 0o755); err != nil {
		return err
	}
	if err := os.MkdirAll(ssl, 0o755); err != nil {
		return err
	}

	if err := ensureStreamLogging(work); err != nil {
		return err
	}
	logRotatePath, err := ensureLogRetentionConfig(work)
	if err != nil {
		return err
	}

	// 2) Write docker-compose.yml if it doesn't already exist
	composeFile := filepath.Join(work, "docker-compose.yml")
	if _, err := os.Stat(composeFile); err == nil {
		// file exists, don't overwrite
	} else if os.IsNotExist(err) {
		// Use host networking so the container can bind all host ports it needs
		composeContent := fmt.Sprintf(`version: "3"
services:
  app:
    container_name: npm
    image: %s
    restart: unless-stopped
    network_mode: "host"
    volumes:
      - %s:/data
      - %s:/etc/letsencrypt
      - %s:/etc/logrotate.d/nginx-proxy-manager
`, image, data, ssl, logRotatePath)

		if err := os.WriteFile(composeFile, []byte(composeContent), 0o644); err != nil {
			return err
		}
	} else {
		return err
	}

	// 3) Run docker compose up -d
	cmd := exec.Command("docker", "compose", "up", "-d")
	cmd.Dir = work // run in project directory
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return err
	}

	return nil
}

func ensureStreamLogging(work string) error {
	customDir := filepath.Join(work, "npm-data", "nginx", "custom")
	if err := os.MkdirAll(customDir, 0o755); err != nil {
		return err
	}

	streamConfPath := filepath.Join(customDir, "stream.conf")
	if _, err := os.Stat(streamConfPath); err != nil {
		if errors.Is(err, os.ErrNotExist) {
			content := `# Auto-generated by 512SvMan to enable stream access logs
log_format stream_proxy_512 '$remote_addr [$time_local] $protocol $status $bytes_sent $bytes_received $session_time [$server_addr:$server_port] -> $upstream_addr';
access_log /data/logs/stream-proxy.log stream_proxy_512;
`
			if writeErr := os.WriteFile(streamConfPath, []byte(content), 0o644); writeErr != nil {
				return writeErr
			}
		} else {
			return err
		}
	}

	return nil
}

func ensureLogRetentionConfig(work string) (string, error) {
	configPath := filepath.Join(work, "npm-data", "logrotate-nginx-proxy-manager")
	content := `/data/logs/*.log {
  daily
  rotate 730
  missingok
  notifempty
  compress
  delaycompress
  copytruncate
}
`
	if current, err := os.ReadFile(configPath); err == nil {
		if string(current) == content {
			return configPath, nil
		}
	} else if !errors.Is(err, os.ErrNotExist) {
		return "", err
	}

	if err := os.WriteFile(configPath, []byte(content), 0o644); err != nil {
		return "", err
	}
	return configPath, nil
}

func DeleteBaseUser(base, email, password string) error {
	//login into new user
	token, err := retry[string](60*time.Second, 2*time.Second, func() (string, error) {
		return Login(base, email, password)
	})
	if err != nil {
		return err
	}

	//delete default admin user
	users, err := GetAllUsers(base, token)
	if err != nil {
		return err
	}
	for _, u := range users {
		if u.Email == adminEmail {
			err := DeleteUser(base, token, u.ID)
			if err != nil {
				return err
			}
			logger.Info("Deleted default admin user", adminEmail)
		}
	}
	return nil
}

type NPMHealth struct {
	Status  string `json:"status"`
	Setup   bool   `json:"setup"`
	Version struct {
		Major    int `json:"major"`
		Minor    int `json:"minor"`
		Revision int `json:"revision"`
	} `json:"version"`
}

type UserAuth struct {
	Type   string `json:"type"`   // "password"
	Secret string `json:"secret"` // password
}

type CreateUserRequest struct {
	Name       string    `json:"name"`
	Nickname   string    `json:"nickname"`
	Email      string    `json:"email"`
	Roles      []string  `json:"roles,omitempty"`
	IsDisabled bool      `json:"is_disabled,omitempty"`
	Auth       *UserAuth `json:"auth,omitempty"`
}

type UserResponse struct {
	ID    int      `json:"id"`
	Email string   `json:"email"`
	Roles []string `json:"roles"`
}

// --------------------
// API helpers
// --------------------

func apiBase(base string) string {
	return strings.TrimRight(base, "/") + "/api"
}

func getHealth(base string) (NPMHealth, error) {
	client := &http.Client{Timeout: 5 * time.Second}

	try := []string{
		apiBase(base),       // .../api
		apiBase(base) + "/", // .../api/
	}

	var lastErr error
	for _, url := range try {
		resp, err := client.Get(url)
		if err != nil {
			lastErr = err
			continue
		}
		defer resp.Body.Close()

		if resp.StatusCode >= 500 {
			lastErr = fmt.Errorf("health %s status %d", url, resp.StatusCode)
			continue
		}

		body, _ := io.ReadAll(resp.Body)
		if resp.StatusCode != 200 {
			lastErr = fmt.Errorf("health %s status %d: %s", url, resp.StatusCode, strings.TrimSpace(string(body)))
			continue
		}

		var h NPMHealth
		if err := json.Unmarshal(body, &h); err != nil {
			lastErr = err
			continue
		}
		return h, nil
	}
	return NPMHealth{}, lastErr
}

func waitForSetupTrue(base string, timeout time.Duration) error {
	deadline := time.Now().Add(timeout)
	for time.Now().Before(deadline) {
		h, err := getHealth(base)
		if err == nil && h.Setup {
			return nil
		}
		time.Sleep(2 * time.Second)
	}
	return fmt.Errorf("setup did not become true within %s (base=%s)", timeout, base)
}

func CreateUser2(base, token string, req CreateUserRequest) (UserResponse, error) {
	var out UserResponse

	b, err := json.Marshal(req)
	if err != nil {
		return out, err
	}

	url := apiBase(base) + "/users"
	httpReq, err := http.NewRequest("POST", url, bytes.NewReader(b))
	if err != nil {
		return out, err
	}
	httpReq.Header.Set("Content-Type", "application/json")
	if token != "" {
		httpReq.Header.Set("Authorization", "Bearer "+token)
	}

	client := &http.Client{Timeout: 12 * time.Second}
	resp, err := client.Do(httpReq)
	if err != nil {
		return out, err
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	if resp.StatusCode < 200 || resp.StatusCode > 299 {
		return out, fmt.Errorf("POST %s -> %d: %s", url, resp.StatusCode, strings.TrimSpace(string(body)))
	}

	if err := json.Unmarshal(body, &out); err != nil {
		return out, err
	}
	return out, nil
}

// --------------------
// Prompt + validation helpers (English)
// --------------------

func readLine(r *bufio.Reader) (string, error) {
	s, err := r.ReadString('\n')
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(s), nil
}

func promptNonEmpty(r *bufio.Reader, label string) (string, error) {
	for {
		fmt.Print(label)
		s, err := readLine(r)
		if err != nil {
			return "", err
		}
		if s == "" {
			fmt.Println("Value cannot be empty. Please try again.")
			continue
		}
		return s, nil
	}
}

func isValidEmail(s string) bool {
	if !strings.Contains(s, "@") {
		return false
	}
	_, err := mail.ParseAddress(s)
	return err == nil
}

func promptEmailConfirmed(r *bufio.Reader) (string, error) {
	for {
		email, err := promptNonEmpty(r, "Admin email: ")
		if err != nil {
			return "", err
		}
		if !isValidEmail(email) {
			fmt.Println("Invalid email format. Example: admin@example.com")
			continue
		}

		fmt.Print("Confirm email: ")
		confirm, err := readLine(r)
		if err != nil {
			return "", err
		}
		if email != confirm {
			fmt.Println("Emails do not match. Please try again.")
			continue
		}
		return email, nil
	}
}

func promptPasswordConfirmed(r *bufio.Reader, minLen int) (string, error) {
	for {
		pass, err := promptNonEmpty(r, fmt.Sprintf("Admin password (min %d chars): ", minLen))
		if err != nil {
			return "", err
		}
		if len(pass) < minLen {
			fmt.Printf("Password too short (got %d chars). Please try again.\n", len(pass))
			continue
		}

		fmt.Print("Confirm password: ")
		confirm, err := readLine(r)
		if err != nil {
			return "", err
		}
		if pass != confirm {
			fmt.Println("Passwords do not match. Please try again.")
			continue
		}
		return pass, nil
	}
}

func promptYesNo(r *bufio.Reader, label string) (bool, error) {
	for {
		fmt.Print(label)
		s, err := readLine(r)
		if err != nil {
			return false, err
		}
		switch strings.ToLower(strings.TrimSpace(s)) {
		case "y", "yes":
			return true, nil
		case "n", "no":
			return false, nil
		default:
			fmt.Println("Please answer with y/n.")
		}
	}
}

// --------------------
// Main: SetupNPM
// --------------------

func SetupNPM(base string) error {
	logger.Info("Pulling and starting NPM container…")
	if err := PullImage(); err != nil {
		return err
	}

	// keep your existing readiness waits
	if err := waitForNPM(base, 2*time.Minute); err != nil {
		return err
	}
	logger.Info("NPM is reachable (UI).")

	if err := waitForAPI(base, 1*time.Minute); err != nil {
		return err
	}
	logger.Info("NPM API is reachable.")

	h, err := getHealth(base)
	if err != nil {
		return err
	}

	logger.Info(fmt.Sprintf("NPM health OK (v%d.%d.%d) setup=%v",
		h.Version.Major, h.Version.Minor, h.Version.Revision, h.Setup))

	// If already set up, nothing to do here (no “first user” wizard)
	if h.Setup {
		logger.Info("NPM is already set up (setup=true). Skipping first user creation.")
		return nil
	}

	// setup=false: create FIRST user (no token)
	reader := bufio.NewReader(os.Stdin)

	fmt.Println("NPM is not set up yet (setup=false). We will create the first admin user now.")

	email, err := promptEmailConfirmed(reader)
	if err != nil {
		return err
	}
	name, err := promptNonEmpty(reader, "Admin full name: ")
	if err != nil {
		return err
	}
	nick, err := promptNonEmpty(reader, "Admin nickname (username): ")
	if err != nil {
		return err
	}
	pass, err := promptPasswordConfirmed(reader, 8)
	if err != nil {
		return err
	}

	ok, err := promptYesNo(reader, "Proceed with user creation? (y/n): ")
	if err != nil {
		return err
	}
	if !ok {
		return fmt.Errorf("aborted by user")
	}

	logger.Info("Creating first admin user (setup mode)…")
	created, err := CreateUser2(base, "", CreateUserRequest{
		Name:     name,
		Nickname: nick,
		Email:    email,
		Roles:    []string{"admin"},
		Auth: &UserAuth{
			Type:   "password",
			Secret: pass,
		},
	})
	if err != nil {
		return err
	}
	logger.Info("Created user id=", created.ID, " email=", created.Email)

	// confirm setup switched to true
	if err := waitForSetupTrue(base, 30*time.Second); err != nil {
		return err
	}
	logger.Info("Confirmed: setup=true ✅")

	return nil
}
func MakeRequest(method, url, token string, body io.Reader, timeoutSeconds int) (*http.Response, error) {
	req, err := http.NewRequest(method, url, body)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	if token != "" {
		req.Header.Set("Authorization", "Bearer "+token)
	}
	client := &http.Client{Timeout: time.Duration(timeoutSeconds) * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}
