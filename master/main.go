package main

import (
	"512SvMan/api"
	"512SvMan/db"
	"512SvMan/env512"
	"512SvMan/logs512"
	"512SvMan/protocol"
	"512SvMan/services"
	"bytes"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	logger "github.com/Maruqes/512SvMan/logger"
	"google.golang.org/grpc"
)

func newSlave(addr, machineName string, conn *grpc.ClientConn) error {

	logger.Info("Mounting all NFS")
	nfsService := services.NFSService{}
	err := nfsService.UpdateNFSShit()
	if err != nil {
		logger.Error("UpdateNFS failed: %v", err)
		return err
	}

	time.Sleep(time.Second * 15)

	logger.Info("Auto starting vms")
	virshServices := services.VirshService{}
	err = virshServices.StartAutoStartVms()
	if err != nil {
		logger.Error("UpdateNFS failed: %v", err)
		return err
	}

	return nil
}

func askForSudo() {
	//if current program is not sudo terminate
	if os.Geteuid() != 0 {
		fmt.Println("This program needs to be run as root.")
		os.Exit(0)
	}
}

func execCommand(name string, arg ...string) error {
	cmd := exec.Command(name, arg...)
	var stderr bytes.Buffer
	cmd.Stdout = os.Stdout
	cmd.Stderr = io.MultiWriter(os.Stderr, &stderr)

	if err := cmd.Run(); err != nil {
		msg := strings.TrimSpace(stderr.String())
		if msg != "" {
			return fmt.Errorf("%w: %s", err, msg)
		}
		return err
	}
	return nil
}

func downloadNoVNC() error {
	//check if folder novnc exists
	if _, err := os.Stat("./novnc"); os.IsNotExist(err) {
		//download novnc from github
		fmt.Println("Downloading noVNC...")
		//use "git clone https://github.com/novnc/noVNC.git novnc"
		err := execCommand("git", "clone", "https://github.com/novnc/noVNC.git", "novnc")
		if err != nil {
			return err
		}
	} else {
		fmt.Println("noVNC folder already exists, trying to update...")
		//update novnc to latest version
		err := execCommand("git", "-C", "novnc", "pull")
		if err != nil {
			return err
		}
	}

	return nil
}

func GoAccess() error {
	if _, err := exec.LookPath("goaccess"); err != nil {
		if _, err := exec.LookPath("dnf"); err != nil {
			return fmt.Errorf("dnf package manager not found: %w", err)
		}

		fmt.Println("Installing GoAccess via dnf...")
		if err := execCommand("dnf", "-y", "install", "goaccess"); err != nil {
			return fmt.Errorf("install GoAccess: %w", err)
		}
	} else {
		fmt.Println("GoAccess already installed, ensuring configuration is up to date.")
	}

	workDir, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("getwd: %w", err)
	}

	npmDataDir := filepath.Join(workDir, "npm-data")
	logDir := filepath.Join(npmDataDir, "logs")
	if err := os.MkdirAll(logDir, 0o755); err != nil {
		return fmt.Errorf("create log dir: %w", err)
	}

	confPath := filepath.Join(npmDataDir, "goaccess.conf")
	confContent := `# Auto-generated by 512SvMan
time-format %H:%M:%S
date-format %d/%b/%Y
log-format [%d:%t %^] %^ %^ %s - %m %^ %v "%U" [Client %h] [Length %b] [Gzip %^] [Sent-to %^] "%u" "%R"
`
	if err := os.WriteFile(confPath, []byte(confContent), 0o644); err != nil {
		return fmt.Errorf("write GoAccess config: %w", err)
	}

	scriptPath := filepath.Join(npmDataDir, "goaccess-run.sh")
	scriptContent := `#!/usr/bin/env bash
set -euo pipefail

BASE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOG_DIR="${BASE_DIR}/logs"
CONF_FILE="${BASE_DIR}/goaccess.conf"

if ! command -v goaccess >/dev/null 2>&1; then
  echo "goaccess binary not found in PATH" >&2
  exit 1
fi

readarray -t files < <(find "$LOG_DIR" -maxdepth 1 -type f \( -name '*_access.log' -o -name 'fallback_access.log' \) | sort)
if [ "${#files[@]}" -eq 0 ]; then
  echo "No access logs found in $LOG_DIR" >&2
  exit 1
fi

exec goaccess "${files[@]}" --config-file="$CONF_FILE" "$@"
`
	if err := os.WriteFile(scriptPath, []byte(scriptContent), 0o755); err != nil {
		return fmt.Errorf("write GoAccess helper script: %w", err)
	}
	if err := os.Chmod(scriptPath, 0o755); err != nil {
		return fmt.Errorf("chmod GoAccess helper script: %w", err)
	}

	return nil
}

func setupFirewallD() error {
	if err := execCommand("firewall-cmd", "--permanent", "--add-service=http"); err != nil {
		return fmt.Errorf("failed to add http service: %w", err)
	}

	if err := execCommand("firewall-cmd", "--permanent", "--add-service=https"); err != nil {
		return fmt.Errorf("failed to add https service: %w", err)
	}

	if err := execCommand("firewall-cmd", "--reload"); err != nil {
		return fmt.Errorf("failed to reload firewall: %w", err)
	}

	return nil
}

func main() {
	askForSudo()

	err := setupFirewallD()
	if err != nil {
		panic(err)
	}

	if err := env512.Setup(); err != nil {
		log.Fatalf("env setup: %v", err)
	}
	logger.SetType(env512.Mode)

	//check if novnc folder exists, if not download it
	err = downloadNoVNC()
	if err != nil {
		log.Fatalf("download noVNC: %v", err)
	}

	err = GoAccess()
	if err != nil {
		log.Fatalf("install GoAccess: %v", err)
	}

	db.InitDB()
	//create all tables if not exists
	err = db.CreateNFSTable()
	if err != nil {
		log.Fatalf("create NFS table: %v", err)
	}

	err = db.CreateVmLiveTable()
	if err != nil {
		log.Fatalf("create vm_live table: %v", err)
	}

	err = db.CreateLogsTable()
	if err != nil {
		log.Fatalf("create logs table: %v", err)
	}

	err = db.CreateISOTable()
	if err != nil {
		log.Fatalf("create ISO table: %v", err)
	}

	err = db.CreateTableBackups()
	if err != nil {
		log.Fatalf("create backups table: %v", err)
	}

	err = db.CreateTableAutoStart()
	if err != nil {
		log.Fatalf("create autostart table: %v", err)
	}

	err = db.CreateTableAutomaticBackup()
	if err != nil {
		log.Fatalf("create autostart table: %v", err)
	}

	//listen and connects to gRPC
	logger.SetCallBack(logs512.LoggerCallBack)
	go protocol.PingAllSlavesLoop()
	protocol.ListenGRPC(newSlave)

	virshService := services.VirshService{}
	virshService.LoopAutomaticBaks()

	api.StartApi()

	select {}
}
